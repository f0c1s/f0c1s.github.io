<html lang="en">
    <head>
    <meta charset="UTF-8">
    <title>blog.f0c1s.com/1000-days-of-golang/day 4</title>
    <script src="../../setup.js" async></script>
    <link rel="stylesheet" href="../../index.css" />
    <link rel="stylesheet" href="../../highlight/styles/monokai.min.css"/>
    <script src="../../highlight/highlight.min.js"></script>

    </head>

<body onload="setup()">
<h1>/f0c1s/blog/1000-days-of-golang/Day 4</h1>

2021.12.30 Thursday

<p>
    <a href="../../index.html">blog</a>
    <a href="../../1000-days-of-golang/1000-days-of-golang.html">1000-days-of-golang</a>
    <a href="../../1000-days-of-golang/day-4-2021.12.30/day-4-2021.12.30.html">+ Day 4 of 1000 days of golang 2021.12.30 Thursday</a>
</p>

## lets go

### recap.

- [mapping over array of numbers](http://blog.f0c1s.com/1000-days-of-golang/day-3-2021.12.28/day-3-2021.12.28.html#mapping-over-an-array-of-numbers)
- [passing a mapping function](http://blog.f0c1s.com/1000-days-of-golang/day-3-2021.12.28/day-3-2021.12.28.html#passing-a-mapping-function)
- [binary search](http://blog.f0c1s.com/1000-days-of-golang/day-3-2021.12.28/day-3-2021.12.28.html#binary-search)
  - math/rand.Perm generates permutaion of numbers; an array of random numbers uptil n 
  - division / operator returns type of first operand
  - you can generate your errors with errors.New(message string)
  - sort.Ints(array) will sort the array
  - rand.Intn(limit) will return a random integer smaller than limit
- [how to generate an array of random numbers](http://blog.f0c1s.com/1000-days-of-golang/day-3-2021.12.28/day-3-2021.12.28.html#how-to-generate-an-array-of-random-numbers)
- [list all files in a directory](http://blog.f0c1s.com/1000-days-of-golang/day-3-2021.12.28/day-3-2021.12.28.html#list-all-files-in-a-directory)
- [HTTP server in go](http://blog.f0c1s.com/1000-days-of-golang/day-3-2021.12.28/day-3-2021.12.28.html#http-server-in-go)

## A little bit more complex Web Server

This web server builds upon the last day's web server.

[HTTP server in go](http://blog.f0c1s.com/1000-days-of-golang/day-3-2021.12.28/day-3-2021.12.28.html#http-server-in-go)

![1.a-bit-more-complex-web-server](1.a-bit-more-complex-web-server.png)

### files/

- index.html
- index.css

Basic html and css files, we are serving these as it is.

### web-server/

#### handlers.go

We are creating route handlers in this file.

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
)

func HelloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "HelloHandler %s\n", r.URL.Query().Get("name"))
}

func HomepageHandler(w http.ResponseWriter, r *http.Request) {
	html, err := ioutil.ReadFile("files/index.html")
	if err != nil {
		fmt.Fprintf(w, "cannot read index.html: "+err.Error())
		return
	}
	fmt.Fprintf(w, string(html))
}

func IndexCssHandler(w http.ResponseWriter, r *http.Request) {
	html, err := ioutil.ReadFile("files/index.css")
	if err != nil {
		fmt.Fprintf(w, "cannot read index.css")
		return
	}
	fmt.Fprintf(w, string(html))
}

```

#### routes.go

We are setting up all the routes here, and assigning route handlers via `http.HandleFunc`.

```go
package main

import "net/http"

func SetupRoutes() {
	http.HandleFunc("/hello", HelloHandler)
	http.HandleFunc("/index.css", IndexCssHandler)
	http.HandleFunc("/", HomepageHandler)
}

```

#### server.go

Setup routes and listen for connections.

```go
package main

import (
	"net/http"
)

func main() {
	SetupRoutes()
	http.ListenAndServe(":8000", nil)
}

```

```shell
$ curl -s http://localhost:8000/         
<h1>index.html</h1>                                                                                                                                                                                                        

$ curl -s http://localhost:8000/hello    
HelloHandler 
                                                                                                                                                                                                        
$ curl -s http://localhost:8000/index.css
h1 {
    color: red;
}    
```

## Gracefully shutting server down

- [blog post](https://medium.com/honestbee-tw-engineer/gracefully-shutdown-in-go-http-server-5f5e6b83da5a)
- [go by example](https://gobyexample.com/signals)
- [Signal characters](https://www.gnu.org/software/libc/manual/html_node/Signal-Characters.html)
- [SO: how-to-stop-http-listenandserve](https://stackoverflow.com/questions/39320025/how-to-stop-http-listenandserve)

### Adding server start failure logic

#### server.go

```go
package main

import (
	"log"
	"net/http"
)

func ListenAndServe() {
	server := &http.Server{Addr: ":8000"}

	if err := server.ListenAndServe(); err != nil {
		log.Println("server cannot start")
		log.Fatalf("server cannot start: %s", err.Error())
	}
}

func main() {
	SetupRoutes()
	ListenAndServe()
}
```

When one instance of server is running, we are going to meet this error:

```shell
$ go build -o server *.go
                                                                                                                                                                                                        
$ ./server               
2021/12/30 14:27:39 server cannot start
2021/12/30 14:27:39 server cannot start: listen tcp :8000: bind: address already in use

```

When no other instance is running on port 8000, and the program can bind to it, then no error:

```shell
$ ./server
^C
```

I also moved files/* to web-server/files/*


Notice that when I send INTR (ctrl+c), it just quits. Go programs can handle it.

### Lets understand ListenAndServe

[http/server.go ListenAndServe](https://go.dev/src/net/http/server.go#L3176)

```go
// ListenAndServe listens on the TCP network address addr and then calls
// Serve with handler to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
//
// The handler is typically nil, in which case the DefaultServeMux is used.
//
// ListenAndServe always returns a non-nil error.
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
```

[http/server.go *Server ListenAndServe](https://go.dev/src/net/http/server.go#L2911)

```go
// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
//
// If srv.Addr is blank, ":http" is used.
//
// ListenAndServe always returns a non-nil error. After Shutdown or Close,
// the returned error is ErrServerClosed.
func (srv *Server) ListenAndServe() error {
	if srv.shuttingDown() {
		return ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
		addr = ":http"
	}
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	return srv.Serve(ln)
}

```

### Handling INTR (ctrl+c)



<script>hljs.highlightAll();</script>
</body>
</html>
