<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
blog.f0c1s.com/node/start-stop
</title>
<link rel="stylesheet" href="../../index.css"/>
<script src="../../setup.js"></script>
<link rel="stylesheet" href="../../highlight/styles/monokai.min.css"/>
<script src="../../highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body onload="setup()">
<h1>
/f0c1s/blog/node/start-stop
</h1>
<nav>
<a href="../../index.html">/blog</a> <a href="../../node/index.html">node</a> <a href="../../node/start-stop/start-stop.html">+ start stop</a>
</nav>
<h2 id="start">Start</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="dt">int</span> Start(<span class="dt">int</span> argc, <span class="dt">char</span>** argv) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  InitializationResult result = InitializeOncePerProcess(argc, argv);</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="cf">if</span> (result.early_return) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="cf">return</span> result.exit_code;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  }</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  {</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    Isolate::CreateParams params;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">size_t</span>&gt;* indices = <span class="kw">nullptr</span>;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="at">const</span> EnvSerializeInfo* env_info = <span class="kw">nullptr</span>;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    <span class="dt">bool</span> use_node_snapshot =</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>        per_process::cli_options-&gt;per_isolate-&gt;node_snapshot;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    <span class="cf">if</span> (use_node_snapshot) {</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>      v8::StartupData* blob = NodeMainInstance::GetEmbeddedSnapshotBlob();</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>      <span class="cf">if</span> (blob != <span class="kw">nullptr</span>) {</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>        params.snapshot_blob = blob;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>        indices = NodeMainInstance::GetIsolateDataIndices();</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>        env_info = NodeMainInstance::GetEnvSerializeInfo();</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>      }</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>    }</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>    uv_loop_configure(uv_default_loop(), UV_METRICS_IDLE_TIME);</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>    NodeMainInstance main_instance(&amp;params,</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>                                   uv_default_loop(),</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>                                   per_process::v8_platform.Platform(),</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>                                   result.args,</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>                                   result.exec_args,</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>                                   indices);</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>    result.exit_code = main_instance.Run(env_info);</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>  }</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>  TearDownOncePerProcess();</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>  <span class="cf">return</span> result.exit_code;</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>}</span></code></pre></div>
<figure>
<img src="1.Start-function.png" alt="" /><figcaption>1.Start-function</figcaption>
</figure>
<p>You can notice event loop being initialized in line 1161.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>InitializationResult InitializeOncePerProcess(<span class="dt">int</span> argc, <span class="dt">char</span>** argv) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="cf">return</span> InitializeOncePerProcess(argc, argv, kDefaultInitialization);</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>}</span></code></pre></div>
<figure>
<img src="2.InitializeOncePerProcess-function.png" alt="" /><figcaption>2.InitializeOncePerProcess-function</figcaption>
</figure>
<p>Weirdly, there are two of these here, same name, different paramlist. I thought this is not possible in C. What magic is this?</p>
<p>Not only this, the function call is passing three params, where as the functions defined accept two or four params.</p>
<p>Welp, just realized, it is CPP. But the non-matching param count is still a mystery to me. May be CPP allows it?</p>
<p>Here is the other function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>InitializationResult InitializeOncePerProcess(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="dt">int</span> argc,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span class="dt">char</span>** argv,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  InitializationSettingsFlags flags,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  ProcessFlags::Flags process_flags) { <span class="co">///</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>From node.cc we jump to node_internals.h for <code>kDefaultInitialization</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">enum</span> InitializationSettingsFlags : <span class="dt">uint64_t</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  kDefaultInitialization = <span class="dv">1</span> &lt;&lt; <span class="dv">0</span>,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  kInitializeV8 = <span class="dv">1</span> &lt;&lt; <span class="dv">1</span>,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  kRunPlatformInit = <span class="dv">1</span> &lt;&lt; <span class="dv">2</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  kInitOpenSSL = <span class="dv">1</span> &lt;&lt; <span class="dv">3</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>};</span></code></pre></div>
<p>Now, <code>1&lt;&lt;0</code> is a fancy way of saying <code>1</code>, but it forms a theme when we look at rest of the enum.</p>
<p><code>InitializeOncePerProcess</code> basically sets up <code>init_flags</code>, calls <code>per_process::enabled_debug_list.Parse</code> for <code>Debug()</code> calls.</p>
<p>Then it sets up <code>ResetStdio</code> to be called when process exits via <code>atexit(ResetStdio)</code>.</p>
<p>Then if the <code>kRunPlatformInit</code> flag is present, which is determined if <code>kDefaultInitialization</code> was passed to the function as <code>flags</code>, it calls <code>PlatformInit</code>.</p>
<p>Some yada yada, and it calls <code>InitializeNodeWithArgs</code> and passes a few data structures via reference to it.</p>
<p>Then it checks for a bunch of <code>cli_options</code> and reaches where it intializes v8 platform via <code>per_process::v8_platform.Initialize</code>.</p>
<p>After which, it checks if <code>kInitializeV8</code> flag is present and if so, it calls <code>V8::Initialize</code>.</p>
<p>Here’s what it looks like in diagrams.</p>
<figure>
<img src="3.node-start.2022.01.15.png" alt="" /><figcaption>3.node-start.2022.01.15</figcaption>
</figure>
<figure>
<img src="4.node-start-InitializeOncePerProcess.2022.01.15.png" alt="" /><figcaption>4.node-start-InitializeOncePerProcess.2022.01.15</figcaption>
</figure>
<p>This is basically all of the first line of the Start function. Then start function gets to create <code>v8::StartupData * blob</code>, initializes <code>uv_default_loop</code> for event looping and runs a <code>NodeMainInstance</code>.</p>
<p>Then it calls <code>TearDownOncePerProcess</code>.</p>
<p>I am going to look a bit deeper into it soon, but before that I am going to take a look at libuv and event_loop implementation.</p>
<details>
<summary>
<h2 id="per_process_node_start_time">
<code>per_process::node_start_time</code>
</h2>
<p></summary></p>
<p>While reading up code we came across <code>node_start_time</code> variable in <code>InitializeNodeWithArgs</code> function.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">// Initialize node_start_time to get relative uptime.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  per_process::node_start_time = uv_hrtime();</span></code></pre></div>
<h3 id="uv__hrtime"><code>uv__hrtime</code></h3>
<p>Following <code>uv_hrtime</code> takes us to uv.h:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>UV_EXTERN <span class="dt">uint64_t</span> uv_hrtime(<span class="dt">void</span>);</span></code></pre></div>
<p>In libuv, this function is present in src/unix/core.c</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">uint64_t</span> uv_hrtime(<span class="dt">void</span>) {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="cf">return</span> uv__hrtime(UV_CLOCK_PRECISE);</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>This takes us to function <code>uv__hrtime</code>, yes, with two underscores.</p>
<p>Shortened version is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="dt">uint64_t</span> uv__hrtime(uv_clocktype_t type) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="dt">static</span> clock_t fast_clock_id = -<span class="dv">1</span>;</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  <span class="kw">struct</span> timespec t;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  clock_t clock_id;</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  clock_id = CLOCK_MONOTONIC;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="cf">if</span> (type != UV_CLOCK_FAST)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    <span class="cf">goto</span> done;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>  clock_id = uv__load_relaxed(&amp;fast_clock_id);</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  <span class="cf">if</span> (clock_id != -<span class="dv">1</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>    <span class="cf">goto</span> done;</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  clock_id = CLOCK_MONOTONIC;</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>  <span class="cf">if</span> (<span class="dv">0</span> == clock_getres(CLOCK_MONOTONIC_COARSE, &amp;t))</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    <span class="cf">if</span> (t.tv_nsec &lt;= <span class="dv">1</span> * <span class="dv">1000</span> * <span class="dv">1000</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>      clock_id = CLOCK_MONOTONIC_COARSE;</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>  uv__store_relaxed(&amp;fast_clock_id, clock_id);</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>done:</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a>  <span class="cf">if</span> (clock_gettime(clock_id, &amp;t))</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;  <span class="co">/* Not really possible. */</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>  <span class="cf">return</span> t.tv_sec * (<span class="dt">uint64_t</span>) <span class="fl">1e9</span> + t.tv_nsec;</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>}</span></code></pre></div>
<p>The library <a href="https://github.com/libuv/libuv" class="in">libuv</a> provides high resolution clock too. I guess thats what’s happening here.</p>
<p>It returns current timestamp according to the clock.</p>
<figure>
<img src="5.libuv-uv__hrtime.png" alt="" /><figcaption>5.libuv-uv__hrtime</figcaption>
</figure>
<p>A few definitions</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">// time.h</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="pp"># define CLOCK_MONOTONIC        1</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="co">// internal.h</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">enum</span> {</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  UV_CLOCK_PRECISE = <span class="dv">0</span>,  <span class="co">/* Use the highest resolution clock available. */</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  UV_CLOCK_FAST = <span class="dv">1</span>      <span class="co">/* Use the fastest clock with &lt;= 1ms granularity. */</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>} uv_clocktype_t;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a><span class="co">// static clock_t fast_clock_id = -1;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a><span class="co">// clock_t.h</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a><span class="kw">typedef</span> __clock_t clock_t;</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a><span class="co">// types.h</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>__STD_TYPE __CLOCK_T_TYPE __clock_t;    <span class="co">/* Type of CPU usage counts.  */</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a><span class="co">// typesizes.h</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a><span class="pp">#define __CLOCK_T_TYPE      __SYSCALL_SLONG_TYPE</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a><span class="pp"># define __SYSCALL_SLONG_TYPE   __SLONGWORD_TYPE</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a><span class="co">// types.h</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a><span class="pp">#define __SLONGWORD_TYPE    long int</span></span></code></pre></div>
<p>Notice these are machine dependent values.</p>
<p><a href="https://en.wikipedia.org/wiki/Integer_(computer_science)#Long_integer">wiki: long int</a></p>
<blockquote>
“A long integer can represent a whole integer whose range is greater than or equal to that of a standard integer on the same machine.”
</blockquote>
</details>
<h2 id="stop">Stop</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="dt">int</span> Stop(Environment* env) {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  env-&gt;ExitEnv();</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>}</span></code></pre></div>
</body>
</html>
